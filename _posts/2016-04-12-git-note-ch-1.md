---
layout: post
title: Git 权威指南 第1篇 初识Git
categories: Git
description: Git权威指南读书笔记第一篇
keywords: Git
---

### 第一篇 初识Git

Git是分布式版本管理系统，区别于CVS和SVN这些集中式版本管理系统。

Git不仅可以实现个人知识的积累，还可以分享库，一大好处啊。

回顾一下版本控制的历史，而后是看看之前的CVS和SVN。

### 第一章 版本控制的前世今生

历史的车轮滚滚向前，慢慢变得厉害，于是Git出现了。

#### 1.黑暗的史前时代

史前时代是黑暗的，但是那个黑暗是秩序和工具的缺乏，而不是自然本身是黑暗的。

一开始是拷贝目录进行简单备份，多人的话就是用文件服务器进行协同，那么大家豆芽编辑的文件该怎么办？肯定和蛋疼。

2000年之前还是史前黑暗的时代，但是即使是在史前时代，也是有很好的源代码比较工具和打补丁的工具：diff和patch。

对于版本控制系统的理解：差异存储，和版本控制系统的使用：代码比价和冲突解决；

1. 用diff命令比较两个文本文件或目录的差异

```bash
$ diff -u hello world > diff.txt
```

输出的差分文件diff.txt当中，首先使用加号和减号标记原始文件和目标文件，减号开始的原始文件，加号开始的目标文件。

2. 命令patch相当于diff的反向操作

```bash
$ patch world < diff.txt
```

没有版本控制的时候，可以用diff和patch记录文件差异。

标准的diff 和patch不支持二进制文件的比较。

#### 2.CVS开启版本控制大爆发

CVS，Concurrent Versions System。并不是设计出来的，很久之前80年代，那是被实际需求给逼出来的设，实用至上。

借用单一文件版本管理工具RCS，CVS是CS设计，版本库在服务端，实际上就是RCS文件容器，每一个RCS文件保存对应文件的每一次更改历史。

#### 3.SVN集中式版本控制集大成者

Subversion在爆发式的版本控制软件兴起中出头，成了CVS的后继者。

#### 4.Git：Linus的第二个伟大作品

Linus不是不喜欢版本控制，是不喜欢集中式的版本控制，所以一开始选了一个分布式的版本控制软件Bitkeeper。

分布式版本控制的不同在于，可以不需要集中式的版本库。每个人都工作在通过克隆监理的本地版本，是自己版本库的主人，对于本地的完整版本库可以实现提交，创建branch，tag等等操作，不需要网络连接。

Git大事记：简单来说，两个月，Git就可以作为Linux的核心版本控制起作用了。到现在为止，使用Git的大型软件项目数不胜数。

### 第二章 爱上Git的理由

举一个典型应用的例子展示Git的用法，以及一些闪亮的特性。

#### 1.每日工作备份

鸡蛋放在一个篮子里肯定是有风险的，所以要做好随时的备份。首先是本地的版本库，笔记本上的。第二个是远程的内网服务器作为第二方案，内网的远程版本库还有一个镜像版本库作为镜像操作，每一次本地向内网远程推送的时候就会触发镜像备份操作，不需要手动触发。

#### 2.异地协同工作

在家里工作一天之后，先push到镜像服务器上的home版本库，不能直接推送mirror的原因是镜像版本库不能直接接收写操作。等到了公司，一天之前首先先拉回home版本库到本地。这样子基本上就是很多台电脑里面有好多备份了。

#### 3.现场版本控制

在客户现场或者在产品部署的现场进行源代码的修改，并且在修改过程中进行版本控制，就叫做现场版本控制。在修改完成后能够将修改结果，修改过程一并带走。

1. SVN的解决方案：（看上去很复杂的，然并卵，先跳过）

2. Git的解决方案：Git修改之后导出提交历史很简单。

（1）创建现场版本库。直接在需要的目录下面创建Git初始化

`$ git init`

（2）添加文件并提交

`
$ git add -A
$ git commit -m "initialized"
`

（3）为初始提交建立一个tag：v1

`$ git tag v1`

（4）开始在工作区中工作------修改文件并提交

`$ git commit -a`

（5）将初始提交开始的所有提交打包成补丁文件带走。导出的补丁文件都包含一个数字前缀，并提取提交日志信息作为文件名。

`
$ git format-patch v1..patch
0001-fix-typo-help-to-help.patch
0002-Add-I18N-support.patch
0003-Translate-for-Chinese.patch
`

（6）邮件生成的补丁文件，反正是文件怎么带走都可以。

备注：生成的patch文件都是Git扩展格式的文件，不能使用GNU的patch命令打补丁，会有错误。使用Git的命令是OK的。

#### 4.避免引入辅助目录

辅助目录就是版本控制工作需要的那些目录，SVN和CVS在每一个子目录下面都要新建辅助目录.svn目录和cvs目录。这些目录出现在Web服务器上是很危险的，最好不要。对文件搜索的结果也不是很好。

Git仅仅在顶级目录下创建辅助文件，如果.git还是很碍眼，也可以移到指定目录，然后执行git命令的时候指定参数就好额。

Git还有一个git grep命令专门优化查找。

#### 5.重写提交说明

提交的说明文字有错怎么办，没有对齐之前的格式怎么办，想要改变之前的提交说明怎么办？

1. SVN的解决方式：默认不允许更改，（然并卵，再说）

2. Git的解决方案：修改最新的提交的说明最简单，用一条命令修补提交就好；如果命令不带-m参数，就会进入提交说明编辑界面

`
$ git commit --amend
`

修改历史提交的提交说明，也可以。这要用到变基命令；修改commit-id所标识的提交说明，在弹出额变基索引文件中修改相应提交前面的动作的关键字。

`
$ git rebase -i <commit-id>^
`

#### 6.想吃后悔药

加入了不该加入的文件怎么办，简单删除也许可以，但是还是会保留在历史当中。

1. SVN的解决方案：然并卵

2. Git：每个人都是管理员：其实就是版本库的整理操作，可以使用修补提交的操作

`
$ git rm --cached winxp.img
$ git commit --amend
`

如果是历史版本，<commit-id>所标识的提交中引入的文件，要使用变基操作

`
$ git rebase -i <commit-id>^
`

执行交互式变基操作抛弃历史提交，版本库还不行，具体再看。

#### 7.更好用的提交列表

一次提交只干一件事情，完成了一个阶段性的工作，比如修了一个Bug，写了一节内容，加了一个文件之后就提交一次，如果是夯不啷当一起提交，那就不是版本控制，是备份系统了。

在一个工作区里面可能同时做好几件事情，全部修改的文件一次提交显然不合理，挑选一件事情相关的文件，然后河道一个commit里面，生成提交列表比较OK。

**Git的解决方案**

Git通过提交暂存区实现对提交内容的定制。

- 使用git add 命令将修改的内容加入暂存区，命令参数功能各不相同，-u可以将所有修改过的文件加入暂存区，-A是本地删除的文件和新增文件都登记，-p可以对一个文件内修改内容进行有选择的添加。

### 流程图
```flow
st=>start: Start
e=>end
op=>operation: My Operation
cond=>condition: Yes or No?

st->op->cond
cond(yes)->e
cond(no)->op
```

以及时序图:

```sequence
Alice->Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob-->Alice: I am good thanks!
```


